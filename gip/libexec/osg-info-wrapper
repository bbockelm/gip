#!/usr/bin/perl -w
use strict;
use POSIX;
use File::stat;
use FileHandle;

# Set our process group to a distinct value
setpgrp();

#Read in the configuration file.
my %config = (
        static_dir => '',
        plugin_dir => '',
        provider_dir => '',
        cache_ttl => '',
        freshness => '',
        timeout => '',
        response => '',
        temp_dir => '',
	 );

$ENV{'GIP_LOCATION'} = "$ENV{'VDT_LOCATION'}/gip";
my $conffile = "$ENV{'VDT_LOCATION'}/gip/etc/osg-info-generic.conf";
my $fh = new FileHandle $conffile
	or die "Error: Can't open config file: $conffile\n";
foreach (<$fh>){
	if ((! m/^\#/) & (m/=/)){
	    m/^(.*)=(.*)$/;
	    my $key=$1;
	    my $value=$2;
	    $key=~s/\s+//g;
	    $value=~s/\s+//g;
	    $config{$key}=$value;
	}
}

while ( my ($key, $value) = each(%config) ) {
    if ( ! $config{$key} ){
	print "Error: configuration parameter $key not set.\n";
	exit 2;
	}
}

my @files=glob("$config{static_dir}/*.ldif");
my @static;

foreach(@files){
    #Reads the static ldif.
    open (STATIC, "$_") || die "Couldn't open config file, $_\n";
    while (<STATIC>) {
	push @static, $_;
    }
    close (STATIC);
}

chomp($config{temp_dir});
mkdir($config{temp_dir});

my @dynamic;
my @dynamic_ldif;
my @provider;
my $pid;
my @pid;
my $file_time;
my $current_time=time;

#Remove junk files.
my @junk;
push @junk, glob("$config{plugin_dir}/*~");
push @junk, glob("$config{provider_dir}/*~");
push @junk, glob("$config{plugin_dir}/\#*");
push @junk, glob("$config{provider_dir}/\#*");

foreach(@junk){
    remove($_);
}

@dynamic=glob("$config{plugin_dir}/*");
@provider=glob("$config{provider_dir}/*");

for(@dynamic, @provider){
    my $chksum = unpack("%64C*", $_);
    my @file= split ( );
    $file[0]=~s/.*\///;

    if(! -e "$config{temp_dir}/$file[0].ldif.$chksum"){
	system("touch $config{temp_dir}/$file[0].ldif.$chksum");
	$file_time = $current_time - 21;
    }
    else{
	$file_time=stat("$config{temp_dir}/$file[0].ldif.$chksum");
	if($file_time){
	    $file_time=$file_time->mtime;
	}else{
	    $file_time=0;
	}
    }

    if($file_time + $config{freshness} <  $current_time ){
	
	# Fork the search.
	unless ($pid=fork){
	    
	    close STDOUT;

	    # Set our process group to a distinct value.
	    setpgrp();
	    my $PGRP=getpgrp();
	    
	    # Eval will kill the process if it times out.
	    eval { 
		local $SIG{ALRM} = sub { die "GOT TIRED OF WAITING" };
		alarm ($config{timeout});  #Will call alarm after the timeout. 
		system("$_ > $config{temp_dir}/$file[0].ldif.$chksum.$PGRP");
		`mv $config{temp_dir}/$file[0].ldif.$chksum.$PGRP $config{temp_dir}/$file[0].ldif.$chksum`;
		alarm(0);           # Cancel the pending alarm if responds.
	    };
	    
	    # This sections is executed if the process times out.
	    if ($@ =~ /GOT TIRED OF WAITING/) {
		`rm -f $config{temp_dir}/$file[0].ldif.$chksum.$PGRP`;
		kill (-SIGKILL(), $PGRP);
		exit 1;
	    }
	    exit 0;
	}
	push @pid, $pid;
    }
}

# Eval will kill the process if it times out.
eval { 
    local $SIG{ALRM} = sub { die "GOT TIRED OF WAITING" };
    alarm ($config{response});  #Will call alarm after the timeout.
    foreach(@pid){
	waitpid($_,0);
    }
    alarm(0);           # Cancel the pending alarm if responds.
};

for(@provider){
    my $chksum = unpack("%64C*", $_);
    my @file= split ( );
    $file[0]=~s/.*\///;
    $file_time=stat("$config{temp_dir}/$file[0].ldif.$chksum");
    if($file_time){
	$file_time=$file_time->mtime;
    }else{
	$file_time=$current_time;
    }
    if($file_time + $config{cache_ttl} >  $current_time ){
	#Reads the output from the provider script.
	open (PROVIDER, "$config{temp_dir}/$file[0].ldif.$chksum") or exit 1;
	while (<PROVIDER>) {
	    push @static, $_;
	}
	close PROVIDER;
    }
}

for(@dynamic){
    my $chksum = unpack("%64C*", $_);
    my @file= split ( );
    $file[0]=~s/.*\///;
    $file_time=stat("$config{temp_dir}/$file[0].ldif.$chksum");
    if($file_time){
	$file_time=$file_time->mtime;
    }else{
	$file_time=$current_time;
    }
    if($file_time + $config{cache_ttl} >  $current_time ){
	#Reads the output from the dynamic script.
	open (DYNAMIC, "$config{temp_dir}/$file[0].ldif.$chksum") or exit 1;
	while (<DYNAMIC>) {
	    push @dynamic_ldif, $_;
	}
	close DYNAMIC;
    }
}

my $static_dn;    
my $static_value;  
my $static_attribute="";     
my $dynamic_dn;   
my $dynamic_value; 
my $dynamic_attribute; 
my $last_dynamic="";

for(@static){
    if (/^dn:.*/){
	$static_dn=$_;
	print "\n$static_dn";
	$static_dn=~s/\s+//g;
	$last_dynamic="" ; 
    }elsif(m/^([^:]*:)(.*)/){
	if($last_dynamic eq $1 ){
	    next;
	}else{
	    $static_attribute=$1;
	    $static_value=$2;
	}
	for (@dynamic_ldif){
	    if (/^dn:.*/){
		$dynamic_dn=$_;
		$dynamic_dn=~s/\s+//g;
	    }elsif(m/^([^:]*:)(.*)/){
		$dynamic_attribute=$1;
		$dynamic_value=$2;
		if (lc($dynamic_dn) eq lc($static_dn)){
		    if ($dynamic_attribute eq $static_attribute){
 			print "$dynamic_attribute$dynamic_value\n";
			$last_dynamic=$dynamic_attribute;
			undef $static_value;
		    }
		}
	    }	       
	}
	if($static_value){
	    print "$static_attribute$static_value\n";
	    undef $static_value;
	}
    }
}

print "\n";
exit;

