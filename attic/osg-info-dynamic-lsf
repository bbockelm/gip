#!/usr/bin/env perl
use strict;

my %output;    # ldif output that is sent to std out.
my $ldif_file; # File name for the static ldif file
my @ldif_file; # Content of the static ldif file
my $binPath;   # Path for LSF executables.
my @dn;        # A dn found in the static lidf file.
my $queue;     # The name of a queue in the batch system.
my $bmgroup;   # The name of the group in the batch system.
my @bmhosts;   # A list of hosts in our queue.
my %hosts;     # A hash of Worker Nodes and no of cpus.
my %host_free; # A hash of Worker Nodes and no of free cpus.
my $TotalCPUs; 
my $FreeCPU;
my $TotalJobs;
my $MaxCPUTime;
my $QueuedJobs;
my $RunningJobs;
my $UsedTime;
my $MaxJobs;
my $MaxWallTime;

my @line;      # A line from running a command.
my @tmp;       # A helper variable.
my $i;         # Used in interations.
my $Time;      # Used in equations.
my $site_active;

my $dir = `dirname $0`;
chomp $dir;
chdir "$dir" or die "Can't cd to $dir: $!\n";

if ($ARGV[1]) {
    $binPath= $ARGV[0];
    $ldif_file= $ARGV[1];
} else {
    print "Usage: $0 <LSF bin path> <lsf file> \n";
    exit 1
}




#Gets the content of the static ldif file
open (LDIF, $ldif_file) || die "Cannot open '$ldif_file': $!,";
while (<LDIF>) {
    push @ldif_file, $_;
}
close (LDIF);  	

#Gets the dns from the static ldif file.
for (@ldif_file){
    if(/dn:\s+GlueCEUniqueID=/){
	push @dn, "$_";
    }
}

#For each dn find the values and print the entry
for(@dn){

    #Print the dn and gets the queue name from the dn.
    print "$_";
    m/=.*:\d+\/\w+-\w+-(\w+)/;
    $queue=$1;

    # Get LRMS version
    open LSID, "$binPath/lsid 2>&1 |" or die "Error running lsid.\n";
    while(<LSID>) {
	if (m/LSF\s+(\d+.\d+),/){
	    chomp;
	    $output{GlueCEInfoLRMSVersion}=$1;
	}
    }
    close LSID;

    
    # Get Information about the batch system. 
    open (BQUEUES, "$binPath/bqueues -l $queue |") or die "Error running bqueues.\n";
    
    @bmhosts = ();
    while(<BQUEUES>) {
	s/[ ]+/ /g;
	@line= split;
	if(m/HOSTS:/){
	    $bmgroup="";
	    for(@line){
		if (m/^all$|\//) {
		    s/\///g;
		    $bmgroup=$bmgroup . " " . $_;
		}elsif(! m/:/){
		    push @bmhosts, $_;
		}
	    }
	}
	
	$i=0;
	if ($MaxJobs){
	    if("$line[$MaxJobs]" eq "-"){
		$line[$MaxJobs]="0";
	    }
	    $output{GlueCEPolicyMaxRunningJobs}=$line[$MaxJobs];
	    undef $MaxJobs;
	}
	if ($QueuedJobs){
	    $output{GlueCEStateWaitingJobs}=$line[$QueuedJobs];
	    undef $QueuedJobs;
	}
	if ($RunningJobs){
	    $output{GlueCEStateRunningJobs}=$line[$RunningJobs];
	    undef $RunningJobs;
	}
        if ($TotalJobs){
            $output{GlueCEStateTotalJobs}=$line[$TotalJobs];
            undef $TotalJobs;
        }
	if ($MaxCPUTime){
	    undef @tmp;
	    for(@line){
		if ( m/(\d+)\.\d+/ ){
		    push @tmp, $1;
		}
	    }
	    $output{GlueCEPolicyMaxCPUTime}= $tmp[$MaxCPUTime-1];
	    undef $MaxCPUTime;
	}
	if ($MaxWallTime){
	    for(@line){
		if ( m/(\d+)\.\d+/ ){
		    push @tmp, $1;
		}
	    }
	    $output{GlueCEPolicyMaxWallClockTime}=$tmp[$MaxWallTime];
	    undef $MaxWallTime;
	}

	for (@line){
	  SWITCH:{ 
	      (m/^MAX$/) && do { $MaxJobs= $i; };
	      (m/^PEND$/) && do { $QueuedJobs= $i; };
	      (m/^RUN$/) && do { $RunningJobs= $i; };
	      (m/^NJOBS$/) && do { $TotalJobs= $i; };
	      (m/^CPULIMIT$/) && do { $MaxCPUTime=$i+1; };
	      (m/^RUNLIMIT$/) && do { $MaxWallTime=$i; };
            }
	    $i=$i+1;
         }
      }
      close BQUEUES;

#Get a hash of WN hostnames and num of CPUS.
open (LSHOSTS, "$binPath/lshosts -w | awk \'{print \$1 \" \"  \$5; }\' |") or die "Error running lshosts.\n";
my $hostname = "";
while(<LSHOSTS>){
    if( m/(^[a-zA-Z][0-9A-Za-z\-\.]+) (\d)/){
        $hostname = $1;
	($hostname) = split /\./, $hostname;
	$hosts{$hostname}=$2;
    }elsif( m/(^[a-zA-Z][0-9A-Za-z\-\.]+) /){
	$hosts{$1}=0;
    }
}
close LSHOSTS;

#Remove unavailible WN and get num of free CPUs.

open (BHOSTS, "$binPath/bhosts | awk \'{print \$1 \" \" \$2 \" \" \$4 \" \" \$5; }\' |") or die "Error running bhosts.\n";
while(<BHOSTS>){
    if( m/(^[a-zA-Z][0-9A-Za-z\-\.]+)\s+unavail/){
	$hosts{$1}=0;
    }elsif(m/(^[a-zA-Z][0-9A-Za-z\-\.]+)\s\w+\s(\d)\s(\d)/){
	if($2 >0 ){
	    $hostname = $1;
	    ($hostname) = split /\./, $hostname;
	    $host_free{$hostname}=($2-$3)*($hosts{$hostname}/$2);
	}
    }
    
}
close BHOSTS;

# If host is in our group add CPU to total. 
    $TotalCPUs=0;
    $FreeCPU=0;
    if ( $bmgroup){
        if ($bmgroup =~ /\Wall$/) {
	    @bmhosts=keys(%hosts);
        } else {
	    open (BMGROUP, "$binPath/bmgroup -r $bmgroup |") or die "Error running bmgroup.\n";
	    while(<BMGROUP>){
		@line=split;
		for (@line){
		    if($hosts{$_}){
			$TotalCPUs=$TotalCPUs+$hosts{$_};
		    }
		    if($host_free{$_}){
			$FreeCPU=$FreeCPU+$host_free{$_};
		    }
		}
	    }
	    close BMGROUP;
	}
    }
    for(@bmhosts){
	if($hosts{$_}){
	    $TotalCPUs=$TotalCPUs+$hosts{$_};
	}
	if($host_free{$_}){
	    $FreeCPU=$FreeCPU+$host_free{$_};
	}
    }

    $FreeCPU=~s/\..*//;
    $output{GlueCEInfoTotalCPUs}=$TotalCPUs;
    $output{GlueCEStateFreeCPUs}=$FreeCPU;

    $output{GlueCEStateFreeJobSlots} = $FreeCPU;
    $output{GlueCEPolicyAssignedJobSlots} = $TotalCPUs;

   #Get used Time
    $UsedTime=0;
    open (BJOBS, "$binPath/bjobs -l -u all -r -q $queue 2>/dev/null | grep CPU | awk '{print \$6;}' |") or die "Error running bjobs.\n";
while (<BJOBS>){
    $UsedTime=$UsedTime+$_;
}
    close BJOBS;
    
    #Calculate Response Times.
    $Time=(($output{GlueCEStateTotalJobs} * $output{GlueCEPolicyMaxWallClockTime}) - $UsedTime) * 60 / $output{GlueCEInfoTotalCPUs};
    $Time=~s/\..*//;
    if ($Time < 0){ $Time = 0;}
    $output{GlueCEStateWorstResponseTime}=$Time;
    $Time=$Time/2;
    $Time=~s/\..*//;
    $output{GlueCEStateEstimatedResponseTime}=$Time;

    read_site_active_info();
    if($site_active==1){
        $output{'GlueCEStateStatus'} = "Production";
    }else{
        $output{'GlueCEStateStatus'} = "Closed";
    }


    #Print the attributes.
    foreach $i (sort keys %output){
	print "$i: $output{$i}\n";
    }
    print "\n";
}


sub read_site_active_info
{
    my $conf = "../../MIS-CI/etc/grid-site-state-info";

    if (-e $conf){
        my $output = `. $conf; echo \$grid_site_state_bit`;
        my @outList = split /\n/, $output;
        if(exists $outList[0]){
            $site_active = $outList[0];
        }else{
            $site_active = 0;
        }

    }else{
        $site_active=0;
    }

}


