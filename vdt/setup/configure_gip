#!/usr/bin/env perl

=head1 configure_gip

configure_gip - Generic Information Provider configuration script

=head2 Synopsis

    configure_gip --vdt-install <VDT installation root>
                  --usage
          --help

=head2 Description

=over 4


=item B<--vdt-install> <VDT installation root>

B<configure_gip> will look for the root of the VDT installation at
$VDT_LOCATION.  If you do not have that set you can specify it
with --vdt-install instead.

=item B<--help>, B<--usage>

Print a usage message.

=back

The following changes will be made:

=over 4

=item $VDT_LOCATION/globus/etc/grid-info-slapd.conf is edited to
    include the GLUE Schema.

=item $VDT_LOCATION/gip/etc/osg-info-generic.conf is created with some
    default values.

=item grid-info-resource-ldif.conf is configured to use the generic
    information provider and disable the Globus information providers.

=back

After it is done, you will need to:

=over 4

=item Edit $VDT_LOCATION/gip/etc/osg-info-generic.conf to have correct
    default values for your site.

=item Run the following command to create the generic information provider:

$VDT_LOCATION/sbin/osg-info-generic-config $VDT_LOCATION//gip/osg-info-generic.conf

=cut

# This script was originally written by Alain Roy of the VDT team
# It was heavily modified by Shaowen Wang <shaowen-wang@uiowa.edu>
# and Anand Padmanabhan <anand-padmanabhan-1@uiowa.edu> to work
# better in an OSG environment.


use strict;
use Getopt::Long;
use VDTConfigure "Generic-Information-Provider";
use File::Path;
use Text::Wrap;
use FileHandle;
#-----------------------------------------------------------------------
#
# Global Variables
#
#-----------------------------------------------------------------------
my $vdt_location = $ENV{VDT_LOCATION};
my $globus_location;
my $gip_location;
my $condor_bin_location;
my $lsf_bin_location;
my $pbs_bin_location;
my $pbs_qstat;
#my $batchHost;
my $batch;
my $install = 0;
# Read Monalisa properties file to provide pre-entered information
my $ml_prop_exists;
my $grid3_info_conf_exists;
my $grid3_user_vo_map_exists;
my $grid3;
#my $ml_farmname;
my $ml_contact_email;
my $ml_city;
my $ml_country;
my $ml_lat;
my $ml_long;
my $osg_sponsor;
#my $ml_monitor_group;
# Other Monitoring data
my $app;
my $data;
my $tmp;
my $wn_tmp;
my $site_read;
my $site_write;
my $osg_grid;
my $osg_site_name;
my $osg_site_policy;
my $default_se;
my $vo;
my @vo_list;
my %vo_access_roots; ############
my $se_data;
my $disk=1;
my $srm=0;
my $dynamic_dcache=0;
my $gums=1;
my %se_access;
my $sa_path;
my $se_host='srmhost';
my $se_name; ##########
my @gridftp_doors;
#my $se_version;
my $srm_implementation_name = "UNDEFINED";
my $srm_implementation_version = "UNDEFINED";
my $se_access_number = 0;
my $se_access_version = "UNDEFINED";
my $se_control_version = "UNDEFINED";
my $fullhost;
my %user_vo_map;
my %pbsQueues;
my @lsfQueues;
my $have_warnings = 0;
my $se_disk;
my $simplified_srm;
my $simplified_srm_path;
my $testbed;
my $bdii_hostname;
my $bdii_port = 2170;
my $bdii_base = 'mds-vo-name=local,o=grid';
my $bdii_contact;
my %scinfo;

parse_command_line();
initialize();

# The -install flag is undocumented and is only used
# during the installation process. It dumps a bit of information
# into the post-install/README file.
if ($install) {
    installation_remarks();
    exit(0);
}
if (defined $ENV{GLOBUS_HOSTNAME} && $ENV{GLOBUS_HOSTNAME} ne "") {
    $fullhost = $ENV{GLOBUS_HOSTNAME};
} else {
    $fullhost = get_hostname();
}
read_osg_attributes_info();
create_directories();
if ($batch =~ /pbs/i) {
    fix_for_pbs_queues();
} elsif ($batch =~/lsf/i) {
    fix_for_lsf_queues();
}
create_config_file();

# CEMonitor Configuration
# This will check to see if CEMon is even installed
setup_cemon();

vdt_install_log("########## Configured Generic-Information-Provider correctly");

exit(0);

###########################################################################
#
# Function: parse_command_line
# Note:     This function exits if it detects any problem.
#
###########################################################################
sub parse_command_line
{
    GetOptions("vdt-install=s" => \$vdt_location,
               "install"       => \$install,
               "help|usage"    => \&usage);
    usage() unless $vdt_location;

}

###########################################################################
#
# Function: usage
# Purpose:  Print a usage message. Used when command-line parsing detects
#           a problem. Exits.
#
###########################################################################
sub usage
{
    print "Usage: $0 --vdt-install <vdt install root>\n";

    exit 1;
}


###########################################################################
#
# Function: initialize
# Purpose:  Figure out our base directories and make sure they are there.
#
###########################################################################
sub initialize
{
    my $date = `date`;
    chomp($date);
    # Trim a trailing slash so we have nice pathnames.
    if ($vdt_location =~ /^(.*)\/$/) {
        $vdt_location = $1;
    }

    $globus_location = $vdt_location . "/globus";
    $gip_location = $vdt_location . "/gip";

    vdt_install_log("##########");
    vdt_install_log("# Configuring Generic-Information-Provider at $date");
    vdt_install_log("##########");

    vdt_install_log("The Globus location is $globus_location");
    vdt_install_log("The GIP location is $gip_location");

    stat($vdt_location) or die "Error can't access $vdt_location\n";
    stat($globus_location) or die "Error can't access $globus_location\n";
    stat($gip_location) or die "Error can't access $gip_location\n";

    my $tmp_testbed = `$vdt_location/osg-version`;
    if ($tmp_testbed =~ /^OSG-ITB-\d\.\d\.\d/) {
        $testbed = 'Integration';
    $bdii_hostname = 'is-itb.grid.iu.edu';

    } elsif ($tmp_testbed =~ /^OSG-\d\.\d\.\d/) {
        $testbed = 'Production';
    $bdii_hostname = 'is.grid.iu.edu';
    }

    return;
}




###########################################################################
#
# Function: remove_quotes
# Purpose:  Utility function to remove quotes
#
###########################################################################
sub remove_quotes
{
    my $tmp = $_[0];
    $tmp  =~ s/^"(.*)"$/$1/;
    return $tmp;
}

###########################################################################
#
# Function: read_osg_attributes_info
# Purpose:  Sources the $vdt_locaton/monitoring/osg-attributes.conf and reads
#           information about $app, $data and $tmp locations
#
###########################################################################
sub read_osg_attributes_info
{
    my $conf = "$vdt_location/monitoring/osg-attributes.conf";

    if (-e $conf){
        my $output = `echo $conf; . $conf; echo \$OSG_APP; echo \$OSG_DATA; echo \$OSG_WN_TMP; echo \$OSG_SITE_READ; echo \$OSG_SITE_WRITE; echo \$OSG_DEFAULT_SE; echo \$OSG_GRID; echo \$OSG_SITE_NAME; echo \$OSG_SITE_INFO; echo \$OSG_CONTACT_EMAIL; echo \$OSG_SITE_CITY; echo \$OSG_SITE_COUNTRY; echo \$OSG_SITE_LATITUDE; echo \$OSG_SITE_LONGITUDE; echo \$OSG_CONDOR_LOCATION; echo \$OSG_SPONSOR`;
        my @outList = split /\n/, $output;
        $app = &remove_quotes($outList[1]);
        $data = &remove_quotes($outList[2]);
        $wn_tmp = &remove_quotes($outList[3]);
        $site_read = &remove_quotes($outList[4]);
        $site_write = &remove_quotes($outList[5]);
        $default_se = &remove_quotes($outList[6]);
        $osg_grid = &remove_quotes($outList[7]);
        $osg_site_name = &remove_quotes($outList[8]);
        $osg_site_policy = &remove_quotes($outList[9]);
        $ml_contact_email=&remove_quotes($outList[10]);
        $ml_city=&remove_quotes($outList[11]);
        $ml_country=&remove_quotes($outList[12]);
        $ml_lat=&remove_quotes($outList[13]);
        $ml_long=&remove_quotes($outList[14]);
        $condor_bin_location=&remove_quotes($outList[15]);
        $osg_sponsor=&remove_quotes($outList[16]);
        $condor_bin_location.="/bin";
        $grid3_info_conf_exists=1;
    } else {
        $grid3_info_conf_exists=0;
        $app = "UNDEFINED";
        $data = "UNDEFINED";
        $wn_tmp = "UNDEFINED";
        $site_read = "UNDEFINED";
        $site_write = "UNDEFINED";
        $default_se = "UNDEFINED";
        $osg_grid = "UNDEFINED";
        $osg_site_name = $fullhost;
        my @host = split /\./, $osg_site_name;
        $osg_site_name = uc $host[0];

        $osg_site_policy = "UNDEFINED";
        $ml_contact_email= "UNDEFINED";
        $ml_city= "UNDEFINED";
        $ml_country= "US";
        $ml_lat=0;
        $ml_long=0;
        $condor_bin_location="";
        $osg_sponsor="UNDEFINED";


        print wrap("", "", "WARNING: Could not locate $conf.\n");
        $have_warnings=1;

    }


    if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
        $default_se=$fullhost;
    }

    my $vo_file     = "$vdt_location/monitoring/osg-user-vo-map.txt";

    # left voi to voc code for transition to voc after testing interoperability, bugs, etc.
    if (-e $vo_file) {
        #my $vo_file_content = slurp($vo_file);
        #my @vo_list = split /\n/, $vo_file_content;
    #my %voi_to_voc = ();
    #my @voi = ();
    #my @voc = ();
        open(VOFILE,"<$vo_file");
        while (<VOFILE>){
           if (m/^\#/ || m/^\s*$/) {
                #if (m/^\#voi (.*)$/) {
                #        @voi = split(/\s+/, $1);
                #} elsif (m/^\#VOc (.*)$/) {
                #        @voc = split(/\s+/, $1);
                #}
           } else {
                chomp;
                my ($user_nm, $user_vo) = split /\ /;

                my $user_tmp;
                #($user_tmp, $user_vo,)= $user_vo =~ /(us)?(\w)/;
                ($user_tmp, $user_vo,)= $user_vo =~ /^(us)?(.*)/;
                $user_vo_map{$user_nm} = $user_vo;

                my $found= grep {m/^$user_vo$/} @vo_list;
                #foreach $user_tmp (@vo_list) {
                #    if ($user_vo eq $user_tmp) {
                #        $found=1;
                #    }
                #}
                if ($found == 0) {
                    push @vo_list, $user_vo;
                }
            }
        }

        #for (my $tmpi=0; $tmpi<=$#voi; $tmpi++) {
        #        $voi_to_voc{$voi[$tmpi]} = $voc[$tmpi];
        #}

        #for (my $tmpi=0; $tmpi<=$#vo_list; $tmpi++) {
        #        if (defined($voi_to_voc{$vo_list[$tmpi]})) {
        #                $vo_list[$tmpi] = $voi_to_voc{$vo_list[$tmpi]};
        #        }
        #}

        $grid3_user_vo_map_exists=1;
    } else {
        print wrap("", "", "WARNING: VO list file $vo_file not found.\n");
        $have_warnings=1;
        $grid3_user_vo_map_exists=0;
        @vo_list =('osg');
    }




##########################################################
## READ GIP CONFIG #######################################
##########################################################
#this is only temporary, contents of this conf file will
#be added to osg_attributes.conf in future


    my $gip_conf = "$vdt_location/monitoring/gip-attributes.conf";

    if (-e $gip_conf){
        my $output = `echo $gip_conf; . $gip_conf; echo \$OSG_GIP_BATCH; echo \$OSG_GIP_SRM; echo \$OSG_GIP_DISK; echo \$OSG_GIP_SE_NAME; echo \$OSG_GIP_SE_HOST; echo \$OSG_GIP_SA_PATH; echo \$OSG_GIP_SE_DISK; echo \$OSG_GIP_DATA; echo \$OSG_GIP_GUMS; echo \$OSG_GIP_SIMPLIFIED_SRM; echo \$OSG_GIP_SIMPLIFIED_SRM_PATH; echo \$OSG_GIP_SRM_IMPLEMENTATION_NAME; echo \$OSG_GIP_SRM_IMPLEMENTATION_VERSION; echo \$OSG_GIP_SE_ACCESS_VERSION; echo \$OSG_GIP_SE_CONTROL_VERSION; echo \$OSG_GIP_SE_ACCESS_NUMBER; echo \$OSG_GIP_DYNAMIC_DCACHE`;
        my @outList = split /\n/, $output;
        $batch   = &remove_quotes($outList[1]);
        $srm     = &remove_quotes($outList[2]);
        $disk    = &remove_quotes($outList[3]);
        $se_name = &remove_quotes($outList[4]);
        $se_host = &remove_quotes($outList[5]);
        $sa_path = &remove_quotes($outList[6]);
        $se_disk = &remove_quotes($outList[7]);
        $se_data = &remove_quotes($outList[8]);
        $gums = &remove_quotes($outList[9]);
        $simplified_srm = &remove_quotes($outList[10]);
        $simplified_srm_path = &remove_quotes($outList[11]);
 #       $se_version = &remove_quotes($outList[12]);
        $srm_implementation_name =  &remove_quotes($outList[12]);
        $srm_implementation_version =  &remove_quotes($outList[13]);
        $se_access_version =  &remove_quotes($outList[14]);
        $se_control_version =  &remove_quotes($outList[15]);
        $se_access_number =  &remove_quotes($outList[16]);
        $dynamic_dcache = &remove_quotes($outList[17]);

        $scinfo{sc_number}=`. $gip_conf; echo \$OSG_GIP_SC_NUMBER;`;
          for(my $i=1; $i<=$scinfo{sc_number};$i++) {
            my ($scname,$scvendor,$scmodel,$scclock,$scnumpcpus,$scnumlcpus,$scramsize,$scinbound,$scoutbound,$scnodes)=`. $gip_conf; echo \$SC_NAME; echo \$SC_VENDOR; echo \$SC_MODEL; echo \$SC_CLOCK; echo \$SC_NUMPCPUS; echo \$SC_NUMLCPUS; echo \$SC_RAMSIZE; echo \$SC_INBOUND; echo \$SC_OUTBOUND; echo \$SC_NODES`;

            ($scinfo{$i}{scname},$scinfo{$i}{scvendor},$scinfo{$i}{scmodel},$scinfo{$i}{scclock},$scinfo{$i}{scnumpcpus},$scinfo{$i}{scnumlcpus},$scinfo{$i}{scramsize},$scinfo{$i}{scinbound},$scinfo{$i}{scoutbound},$scinfo{$i}{scnodes})=`. $gip_conf; echo \${OSG_GIP_SC_ARR[$i$scname]}; echo \${OSG_GIP_SC_ARR[$i$scvendor]}; echo \${OSG_GIP_SC_ARR[$i$scmodel]}; echo \${OSG_GIP_SC_ARR[$i$scclock]}; echo \${OSG_GIP_SC_ARR[$i$scnumpcpus]}; echo \${OSG_GIP_SC_ARR[$i$scnumlcpus]}; echo \${OSG_GIP_SC_ARR[$i$scramsize]}; echo \${OSG_GIP_SC_ARR[$i$scinbound]}; echo \${OSG_GIP_SC_ARR[$i$scoutbound]}; echo \${OSG_GIP_SC_ARR[$i$scnodes]};`;

            foreach my $val (keys %{$scinfo{$i}}) {
                 chomp($scinfo{$i}{$val});
            }
        }

        if ($srm) {
            #Collecting all gridftp access points stored in grp-attributes.conf
            my $gridftp_doors_all =  `cat $gip_conf | grep ^OSG_GIP_SE_ACCESS_ARR`;
            for (my $i=0; $i<$se_access_number; $i++){
               if ( $gridftp_doors_all =~ m/OSG_GIP_SE_ACCESS_ARR\[$i]="(.*)"/i){
                   my $door = $1;
                   chomp($door);
                   $gridftp_doors[$i]=$door;
               }
            }

            if ($simplified_srm eq "y") {
                    foreach $vo (@vo_list) {
                            $vo_access_roots{$vo} = $simplified_srm_path;
                    }
            } else {

                my $vo_dir_var;
                my $vo_path;
                my $vo_path_conf_str = `cat $gip_conf | grep ^OSG_GIP_VO_DIR`;

                foreach $vo (@vo_list){

                    #$vo_dir_var = "OSG_GIP_VO_".$vo."_DIR";

                # insensitive since osg-gip-configure.sh doesn't do conversion
                    #if ($vo_path_conf_str =~ m/$vo_dir_var.*="(.*)"\n/i){
                    if ($vo_path_conf_str =~ m/OSG_GIP_VO_DIR\[\d+\]="$vo,(.*)"/i){
                        $vo_path = $1;
                        chomp($vo_path);
                        $vo_access_roots{$vo} = $vo_path;
                    } else {
                        print "WARNING - configure_gip: SRM Path for $vo has not been set, rerun configure-osg-gip.sh\n";
                    }
                }
            }
        }

    } else {
        $batch   = "condor";
        $srm     = 0;
        $disk    = 1;
        $se_name = "UNDEFINED";
        $se_host = "UNDEFINED";
        $sa_path = "UNDEFINED";
        $se_disk = $default_se;
        $se_data = "UNDEFINED";
        $gums    = 1;

        foreach $vo (@vo_list){
            $vo_access_roots{$vo} = "UNDEFINED";
        }

        print wrap("", "", "WARNING: Could not locate $gip_conf.\n");
        $have_warnings=1;
    }


    # We figure out what Condor is being used by this installation,
    # if the person wants Condor.
    if ($batch =~ /condor/i) {
        if($condor_bin_location == "") {
            my $condor_setup = "$vdt_location/vdt/etc/condor-env.sh";
            if (-e $condor_setup) {
                # We've installed Condor, which installed the Condor
                # environment setup file. This points to either the
                # VDT Condor, or the pre-existing Condor indicated by
                # the user. We parse this file to figure out the Condor
                # bin path
                my $contents = slurp($condor_setup);
                if ($contents =~ /^CONDOR_LOCATION=(.+)$/m) {
                    $condor_bin_location = $1;
                    $condor_bin_location .= "/bin";
                }
            }
            if ($condor_bin_location eq "") {
                open WHICH, "which condor_q 2>/dev/null |";
                $tmp = <WHICH>;
                chomp($tmp);
                $condor_bin_location = substr("$tmp",0,length($tmp)-9);
            }

            if ($condor_bin_location eq "") {
                $condor_bin_location = "$vdt_location/condor/bin";
            }
            stat($condor_bin_location) or die "Can't find Condor location.\n";
        }
    }
    # Locate lsf binaries
    if ($batch =~ /lsf/i) {
         if ($lsf_bin_location eq "") {
            open WHICH, "which lsid 2>/dev/null |";
            $lsf_bin_location = <WHICH>;
            chomp($lsf_bin_location);
            $lsf_bin_location = substr("$lsf_bin_location",0,length($lsf_bin_location)-5);
        }
        stat($lsf_bin_location) or die "Can't find lsid location, make sure that lsf binaries are in path.\n";

    }
    # Locate pbs binaries
    if ($batch =~ /pbs/i) {
         if ($pbs_qstat eq "") {
            open WHICH, "which qstat 2>/dev/null |";
            $pbs_qstat = <WHICH>;
            chomp($pbs_qstat);
            $pbs_bin_location = substr("$pbs_qstat",0,length($pbs_qstat)-6);
        }
        stat($pbs_qstat) or die "Can't find PBS-qstat location, make sure that qstat is in path.\n";
    }

    $bdii_contact = "ldap://$bdii_hostname:$bdii_port/mds-vo-name=$osg_site_name,$bdii_base";

    return;
}


###########################################################################
#
# Function: installation_remarks
# Purpose:  It's installation time. Let people know what they should do
#           later.
#
###########################################################################
sub installation_remarks
{
    post_install_log("The Generic Information Provider (GIP) has been installed but not configured.  If you" .
                     "wish to use it then you should run $vdt_location/vdt/setup/configure_gip. If" .
                     "you are installing as part of the OSG software stack, the configure_osg.sh program will" .
                     "do this on your behalf.\n\n");
}

###########################################################################
#
# Function: create_directories
# Purpose:  Create GIP directories.
#
###########################################################################
sub create_directories()
{
    my $tmp_dir = "$gip_location/var/tmp";
    if (!-d $tmp_dir) {
        # This will probably create both gip and tmp.
        vdt_install_log("Creating temporary directory for GIP: $tmp_dir");
        system("mkdir -p $gip_location/var/tmp");
    }
    if ($< == 0) {
        system("chown daemon $gip_location/var/tmp");
    }

    #my $plugin_dir  = "$gip_location/var/gip/plugin";
    #if (!-d $plugin_dir) {
    #    # This will probably create plugin.
    #    vdt_install_log("Creating plugin directory for GIP: $plugin_dir");
    #    system("mkdir -p $plugin_dir");
    #}

    #my $provider_dir  = "$gip_location/var/gip/provider";
    #if (!-d $provider_dir) {
    #    vdt_install_log("Creating provider directory for GIP: $provider_dir");
    #    system("mkdir -p $provider_dir");
    #}

    my $ldif_dir  = "$gip_location/var/ldif";
    if (!-d $ldif_dir) {
        vdt_install_log("Creating static ldif directory for GIP: $ldif_dir");
        system("mkdir -p $ldif_dir");
    }else{
        #Clear the existing ldif files - otherwise the information will be duplicated
        vdt_install_log("Clear the existing files in $ldif_dir otherwise the information will be duplicated");
        system("rm -rf $ldif_dir/*");
    }

    if (!-d "$gip_location/etc/osg-info-gip-config"){
        vdt_install_log("Creating directory for GIP: $gip_location/etc/osg-info-gip-config");
        system("mkdir -p $gip_location/etc/osg-info-gip-config");
    }else{
        #Clear the existing config files - otherwise the information will be duplicated
        vdt_install_log("Clear the existing files in $gip_location/etc/osg-info-gip-config otherwise the information will be duplicated");
        system("rm -rf $gip_location/etc/osg-info-gip-config/*");
    }

    foreach $vo (@vo_list){
        vdt_install_log("Creating directory for GIP: $gip_location/var/info/$vo");
        `mkdir -p $gip_location/var/info/$vo`;
        vdt_install_log("Creating file for GIP: $gip_location/var/info/$vo/$vo.list");
        `touch -a $gip_location/var/info/$vo/$vo.list`;
    }

    return;
}


###########################################################################
#
# Function: create_site_config_file
# Purpose:  We create the static conf file gip-info-static-site.conf
#
###########################################################################
sub create_site_config_file
{
    my $config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-site.conf";
    my $contents ="";

   $contents = $contents."dn: GlueSiteUniqueID=$fullhost\n"
                        ."GlueSiteName: $osg_site_name\n"
                        ."GlueSiteDescription: OSG Site\n"
                        ."GlueSiteUserSupportContact: mailto: $ml_contact_email\n"
                        ."GlueSiteSysAdminContact: mailto: $ml_contact_email\n"
                        ."GlueSiteSecurityContact: mailto: $ml_contact_email\n"
                        ."GlueSiteEmailContact: mailto: $ml_contact_email\n"
                        ."GlueSiteLocation: $ml_city,$ml_country\n"
                        ."GlueSiteLatitude: $ml_lat\n"
                        ."GlueSiteLongitude: $ml_long\n"
                        ."GlueSiteSponsor: $osg_sponsor\n"
                        ."GlueSiteOtherInfo: UNDEFINED\n"
                        ."GlueForeignKey: GlueSiteUniqueID=$fullhost\n"
                        ."GlueSiteWeb: $osg_site_policy\n";

    safe_write($config_file, $contents);

    vdt_install_log("===== BEGIN osg-info-static-site.conf =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-site.conf =====\n");

    return;
}
###########################################################################
#
# Function: add_to_pbs_queues
# Purpose:  Helper function for fix_for_pbs_queues
#
###########################################################################
sub add_to_pbs_queues
{
    my ($gp_ptr,$tmp_ptr,$is_user_list) = @_;
    my $tmp_grep;
    my $is_vo;
    my $tmp_vo;

    for my $gp (@$gp_ptr){
       $tmp_vo=$gp;
       if($is_user_list==1){
          if (defined $user_vo_map{$gp}){
             $tmp_vo= $user_vo_map{$gp};
          }else{
             next;
          }
       }
       $is_vo = grep {m/^$tmp_vo$/} @vo_list;
       if ($is_vo!=0) {
          $tmp_grep = grep {m/^$tmp_vo$/} @$tmp_ptr;
          if($tmp_grep == 0){
             push  @$tmp_ptr, $tmp_vo;
          }
       }else{ #Special case for usatlas and uscms (since they may match with atlas and cms)
          my($tmp) = $tmp_vo =~ /(?:us)?([a-zA-Z_]+)\d*/;
          $is_vo = grep {m/^$tmp$/} @vo_list;
          if ($is_vo!=0) {
             $tmp_grep = grep {m/^$gp$/} @$tmp_ptr;
             if($tmp_grep == 0){
                push  @$tmp_ptr, $gp;
             }
          }
       }
    }
}

###########################################################################
#
# Function: fix_for_pbs_queues
# Purpose:  Here we create groups for each queue in pbs rather than each VO.
#           We track that VOs that are allowed to submit the job to queue
#
###########################################################################

sub fix_for_pbs_queues{
    my $queue;
    my $group_enable = 0;
    my $user_enable = 0;
    my $host_enable = 0;
    my @pbs_users;
    my @pbs_groups;
    my @pbs_hosts;
    my $use_queue=0;
    my $lastline=''; # added to fix multi-line acl_{users,groups,hosts}

#    open QSTAT, "$pbs_qstat -Q -f 2>&1 |" or die "Error running qstat ---.\n" ;
    my @qstat_dump=`$pbs_qstat -Q -f 2>&1`or die "Error running qstat ---.\n" ;
    my $line_num;
    my $qstat_len=$#qstat_dump;

    for($line_num=0;$line_num<=$qstat_len;$line_num++){
        if($line_num<$qstat_len){
            $_=$qstat_dump[$line_num];
        }else{
            $_='';
        }
        if(m/Queue:\s*(\S+)\s*/ || $line_num==$qstat_len){
            # Condense and remove undef and make sure it works
            # inititate variables at beginning of Queue (empty array and strings)
            my $tmp_queue=$1;
            my @tmp_groups;
            if($use_queue==1) {
               if($host_enable==1){
                   my $is_valid_host = grep {m/^\s*$fullhost\s*$/} @pbs_hosts;
                   if ($is_valid_host==0){
                       my ($tmp_name,$tmp_aliases,$tmp_addrtype,$tmp_length,@address) = gethostbyname($fullhost);
                       my ($tmpa,$tmpb,$tmpc,$tmpd) = unpack('C4',$address[0]);
                       my $ip = "$tmpa.$tmpb.$tmpc.$tmpd";
                       $is_valid_host = grep {m/^$ip$/} @pbs_hosts;
                       if ($is_valid_host==0){
                           $use_queue=0;
                       }
                   }
               }
               if($use_queue==1) {
                  if($group_enable==1){
                  add_to_pbs_queues(\@pbs_groups,\@tmp_groups,0);
              }
              if($user_enable==1){
                  add_to_pbs_queues(\@pbs_users,\@tmp_groups,1);
              }
              if($user_enable==0 && $group_enable==0){
                  @tmp_groups=@vo_list;
              }
              if($#tmp_groups>=0){
                  @{$pbsQueues{$queue}}=@tmp_groups;
              }
           }
            }
            undef @pbs_groups;
            undef @pbs_users;
            undef @pbs_hosts;
            undef @tmp_groups;
            undef $queue;
            $lastline='';
            $host_enable=0;
            $group_enable = 0;
            $user_enable = 0;
            $use_queue=0;
            $queue = $tmp_queue;
        }
        elsif(m/queue_type\s*=\s*(\S+)\s*/){
            my $queue_type = $1;
            if($queue_type eq "Execution"){
                $use_queue=1;
            }else{
                $use_queue=0;
            }
        }
        elsif(m/\s*acl_host_enable\s*=\s*True\s*/i){
            $host_enable=1;
        }
        elsif(m/\s*acl_group_enable\s*=\s*True\s*/i){
            $group_enable=1;
        }
        elsif(m/\s*acl_user_enable\s*=\s*True\s*/i){
            $user_enable=1;
        }
        elsif(m/\s*acl_groups\s*=\s*(.+)\s*/i){
            @pbs_groups = split /,/, $1;
            $lastline='groups';
        }
        elsif(m/\s*acl_users\s*=\s*(.+)\s*/i){
            @pbs_users = split /,/, $1;
            $lastline='users';
        }
        elsif(m/\s*acl_hosts\s*=\s*(.+)\s*/i){
            @pbs_hosts = split /,/, $1;
            $lastline='hosts';
        }
        elsif($lastline ne '') { # line did not match anything else so double-check its not a multi-line wrap
            if(!(m/\s*=\s*/i)) { # if its not a attr = value statement, then it should be a multi-line wrap
               my @tmparr=split /,/, $_;
               push(@pbs_users,@tmparr)  if $lastline=='users';
               push(@pbs_groups,@tmparr) if $lastline=='groups';
               push(@pbs_hosts,@tmparr)  if $lastline=='hosts';
            }else{ #obviously not a multi-line wrap because we already ran into a attr = value statement
               $lastline='';
            }
        }

    }


}
###########################################################################
#
# Function: fix_for_lsf_queues
# Purpose:  Here we create groups for each queue in pbs rather than each VO.
#           We track that VOs that are allowed to submit the job to queue
#
###########################################################################
sub fix_for_lsf_queues(){
my @bqueues;

@bqueues=`bqueues -w | awk '{print \$1}'`;
foreach my $item (@bqueues) {
   chomp($item);
   if($item ne 'QUEUE_NAME' and $item ne '') {
      push(@lsfQueues,$item);
   }
}

}



###########################################################################
#
# Function: get_os_release
# Purpose:  Get the current OS release
#
###########################################################################
sub get_os_release(){
my $arch;
my $rel;
my $ver;

$arch=`lsb_release -i 2>/dev/null | cut -f2`;
$rel=`lsb_release -r 2>/dev/null | cut -f2`;
$ver=`lsb_release -c 2>/dev/null | cut -f2`;

if(!defined $arch || !$arch){ #If one of the lsb_release doesnot return correct value then all of them should return correct value
    if (-e "/etc/debian_version"){
        my $fh = new FileHandle "/etc/debian_version";
        chomp(my $version = <$fh>);
        $arch = "linux-debian-$version";
        $rel = "Debian Linux";
        $ver=$version;
    }elsif (-e "/etc/rocks-release"){
        my $fh = new FileHandle "/etc/rocks-release";
        chomp(my $version_str = <$fh>);
        my ($version) = $version_str =~ /(\d+\.\d+)/;
        $arch = "linux-rocks-$version";
        $ver = $version;
        $rel = "Rocks Linux";
    }elsif (-e "/etc/redhat-release"){
        my $fh = new FileHandle "/etc/redhat-release";
        chomp(my $version_str = <$fh>);
        if ($version_str =~ /Red Hat Linux (?:release )?([\d\.]+)/){
            $arch = "linux-redhat-$1";
            $ver = $1;
            $rel = "RedHat Linux";
        }elsif ($version_str =~ /Enterprise Linux AS release ([\d\.]+)/){
            $arch = "linux-rhel-$1";
            $ver = $1;
            $rel = "RedHat Enterprise Linux";
        }elsif ($version_str =~ /Fedora Core release ([\d\.]+)/){
            $arch = "linux-fedora-$1";
            $ver = $1;
            $rel = "Fedora Core"
    }elsif ($version_str =~ /Scientific Linux Release (\d\.?\d)(?:\.\d|\d) \(Fermi\)/) {
            my $version = $1;
            $version =~ s/(\d)(\d)/$1.$2/;
            $arch = "linux-sl-fermi-$version";
            $ver = $version;
            $rel = "Scientific Linux";
        }elsif ($version_str =~ /Scientific Linux SL release (\d\.?\d) \(\w+\)/){
            my $version = $1;
            $rel = $3;
            $version =~ s/(\d)(\d)/$1.$2/;
            $arch = "linux-sl-fermi-$version";
            $ver = $version;
        }else{
            $arch="RedHat Generic";
            $rel="RedHat Unknown";
            $ver="Unknown";
        }
    }elsif (-e "/usr/bin/sw_vers"){
        chomp(my $version = `/usr/bin/sw_vers -productVersion`);
        $arch = "darwin-$version";
        $ver = $version;
        $rel = "Darwin";
    }
}
    if(!defined $arch || !$arch){
        $arch = "linux-Unknown";
    }
    if(!defined $ver || !$ver){
        $ver = "Unknown";
    }
     if(!defined $rel || !$rel){
        $rel = "Linux";
    }
chomp($arch);
chomp($ver);
chomp($rel);
return ("$arch", "$ver", "$rel");
}
###########################################################################
#
# Function: get_cpu_info
# Purpose:  Get cpu info from /proc/cpuinfo (DEPRECATED)
#
###########################################################################
sub get_cpu_info(){
    my $model="Pentium IV";
    my $vendor = "Intel";
    my $line;
    if (-e "/proc/cpuinfo"){
        my $file = "/proc/cpuinfo";
        my $contents = slurp($file);
        my @lines = split /\n/, $contents;
        foreach $line (@lines){
            if($line =~ m/^model\s*name\s*\:\s*(.*)$/){
                $model=$1;
                chomp($model);
            }
            if($line=~ m/^vendor_id\s*\:\s*(.*)$/){
                $vendor = $1;
                chomp($vendor);
            }
        }
    }
    return ("$model", "$vendor");
}
###########################################################################
#
# Function: create_cluster_config_file
# Purpose:  We create the static conf file osg-info-static-cluster.conf
#
###########################################################################
sub create_cluster_config_file
{
    my $config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-cluster.conf";
    my $contents    = "";
    $contents = $contents."\ndn: GlueClusterUniqueID=$fullhost\n"
             ."GlueClusterName: $fullhost\n"
             ."GlueClusterService: $fullhost\n"
             ."GlueClusterTmpDir: $data\n"
             ."GlueClusterWNTmpDir: $wn_tmp\n";

    if ($batch =~ /^pbs$/i) {
        foreach my $queue (keys %pbsQueues){
            $contents = $contents."GlueForeignKey: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
        }
    } elsif ($batch =~/lsf/i) {
        foreach my $queue (@lsfQueues){
            $contents = $contents."GlueForeignKey: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
        }
    }else{
        foreach $vo (@vo_list){
            $contents = $contents."GlueForeignKey: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n";
        }
    }
    $contents = $contents."GlueForeignKey: GlueSiteUniqueID=$fullhost\n";
    $contents = $contents."GlueInformationServiceURL: $bdii_contact\n";


    #Change the OSG Version
    my $osg_ver = `$vdt_location/osg-version`;
    chomp($osg_ver);
    my @os = &get_os_release();
    #my @cpu = &get_cpu_info();

    for(my $sc_count=1;$sc_count<=$scinfo{sc_number};$sc_count++) {
        my $pcpus=$scinfo{$sc_count}{scnumpcpus}*$scinfo{$sc_count}{scnodes};
        my $lcpus=$scinfo{$sc_count}{scnumlcpus}*$scinfo{$sc_count}{scnodes};
        $contents = $contents."\ndn: GlueSubClusterUniqueID=$scinfo{$sc_count}{scname}, GlueClusterUniqueID=$fullhost\n"
                 ."GlueChunkKey: GlueClusterUniqueID=$fullhost\n"
                 ."GlueSubClusterName: $scinfo{$sc_count}{scname}\n"
                 ."GlueHostApplicationSoftwareRunTimeEnvironment: $osg_ver\n"
                 ."GlueHostArchitectureSMPSize: $scinfo{$sc_count}{scnumpcpus}\n"
                 ."GlueHostBenchmarkSF00: 380\n"
                 ."GlueHostBenchmarkSI00: 400\n"
                 ."GlueHostMainMemoryRAMSize: $scinfo{$sc_count}{scramsize}\n"
                 ."GlueHostMainMemoryVirtualSize: $scinfo{$sc_count}{scramsize}\n"
                 ."GlueHostNetworkAdapterInboundIP: " . uc($scinfo{$sc_count}{scinbound}) . "\n"
                 ."GlueHostNetworkAdapterOutboundIP: " . uc($scinfo{$sc_count}{scoutbound}) . "\n"
                 ."GlueHostOperatingSystemName: $os[0]\n"
                 ."GlueHostOperatingSystemRelease: $os[2]\n"
                 ."GlueHostOperatingSystemVersion: $os[1]\n"
                 ."GlueHostProcessorClockSpeed: $scinfo{$sc_count}{scclock}\n"
                 ."GlueHostProcessorModel: $scinfo{$sc_count}{scmodel}\n"
                 ."GlueHostProcessorVendor: $scinfo{$sc_count}{scvendor}\n"
                 ."GlueSubClusterPhysicalCPUs: $pcpus\n"
                 ."GlueSubClusterLogicalCPUs: $lcpus\n"
                 ."GlueSubClusterTmpDir: $data\n"
                 ."GlueSubClusterWNTmpDir: $wn_tmp\n"
                 ."GlueInformationServiceURL: $bdii_contact";


        # Add local stograge requirement information
        $contents = $contents."\ndn: GlueLocationLocalID=OSG_SITE_READ, GlueSubClusterUniqueID=$scinfo{$sc_count}{scname}, GlueClusterUniqueID=$fullhost\n"
                             ."GlueLocationName: OSG_SITE_READ\n"
                             ."GlueLocationVersion: UNDEFINED\n"
                             ."GlueLocationPath: $site_read\n"
                             ."GlueChunkKey: GlueClusterUniqueID=$fullhost\n";

        $contents = $contents."\ndn: GlueLocationLocalID=OSG_SITE_WRITE, GlueSubClusterUniqueID=$scinfo{$sc_count}{scname}, GlueClusterUniqueID=$fullhost\n"
                             ."GlueLocationName: OSG_SITE_WRITE\n"
                             ."GlueLocationVersion: UNDEFINED\n"
                             ."GlueLocationPath: $site_write\n"
                             ."GlueChunkKey: GlueClusterUniqueID=$fullhost\n";

        $contents = $contents."\ndn: GlueLocationLocalID=OSG_GRID, GlueSubClusterUniqueID=$scinfo{$sc_count}{scname}, GlueClusterUniqueID=$fullhost\n"
                             ."GlueLocationName: OSG_GRID\n"
                             ."GlueLocationVersion: UNDEFINED\n"
                             ."GlueLocationPath: $osg_grid\n"
                             ."GlueChunkKey: GlueClusterUniqueID=$fullhost\n";
    }
    safe_write($config_file, $contents);

    vdt_install_log("===== BEGIN osg-info-static-cluster.conf =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-cluster.conf =====\n");

    return;
}

###########################################################################
#
# Function: create_ce_config_file
# Purpose:  We create the static conf file osg-info-static-ce.conf
#
###########################################################################
sub create_ce_config_file
{

    my $config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-ce.conf";
    my $contents    = "";

    $contents = $contents."\nGlueCEHostingCluster: $fullhost\n"
                         ."GlueCEInfoGatekeeperPort: 2119\n"
                         ."GlueCEInfoHostName: $fullhost\n"
                         ."GlueCEInfoLRMSType: $batch\n"
                         ."GlueCEInfoLRMSVersion: not defined\n"
                         ."GlueCEInfoTotalCPUs: 0\n"
                         ."GlueCEPolicyMaxCPUTime: 6000\n"
                         ."GlueCEPolicyMaxRunningJobs: 0\n"
                         ."GlueCEPolicyMaxTotalJobs: 0\n"
                         ."GlueCEPolicyMaxWallClockTime: 6000\n"
                         ."GlueCEPolicyPriority: 1\n"
                         ."GlueCEPolicyMaxObtainableWallClockTime: 0\n"
                         ."GlueCEPolicyMaxObtainableCPUTime: 0\n"
                         ."GlueCEPolicyMaxWaitingJobs: 0\n"
                         ."GlueCEPolicyMaxSlotsPerJob: 0\n"
                         ."GlueCEPolicyPreemption: 0\n"
                         ."GlueCEStateEstimatedResponseTime: 14400\n"
                         ."GlueCEStateFreeCPUs: 0\n"
                         ."GlueCEStateRunningJobs: 0\n"
                         ."GlueCEStateStatus: Production\n"
                         ."GlueCEStateTotalJobs: 0\n"
                         ."GlueCEStateWaitingJobs: 0\n"
                         ."GlueCEStateWorstResponseTime: 0\n"
                         ."GlueCEInfoJobManager: $batch\n"
                         ."GlueCEStateFreeJobSlots: 0\n"
                         ."GlueInformationServiceURL: $bdii_contact\n"
                         ."GlueCEPolicyAssignedJobSlots: 0\n"
                         ."GlueCEImplementationName: UNDEFINED\n"
                         ."GlueCEImplementationVersion: UNDEFINED\n"
                         ."GlueCECapability: UNDEFINED\n";

    if ($batch =~ /^pbs$/i) {
        foreach my $queue (keys %pbsQueues){
            $contents = $contents."\ndn: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n"
                                 ."GlueCEName: $queue\n"
                                 ."GlueForeignKey: GlueClusterUniqueID=$fullhost\n"
                                 ."GlueCEInfoContactString: $fullhost:2119/jobmanager-$batch-$queue\n"
                                 ."GlueCEInfoApplicationDir:  $app\n"
                                 ."GlueCEInfoDataDir: $data\n";
            foreach $vo (@{$pbsQueues{$queue}}){
                $contents = $contents."GlueCEAccessControlBaseRule: VO:$vo\n";
            }

            if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
                $contents = $contents."GlueCEInfoDefaultSE:  $fullhost\n";
            } else {
                $contents = $contents."GlueCEInfoDefaultSE: $default_se\n";
            }
        }
    }
    elsif ($batch =~ /^lsf$/i) {
        foreach my $queue (@lsfQueues){
            $contents = $contents."\ndn: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n"
                                 ."GlueCEName: $queue\n"
                                 ."GlueForeignKey: GlueClusterUniqueID=$fullhost\n"
                                 ."GlueCEInfoContactString: $fullhost:2119/jobmanager-$batch-$queue\n"
                                 ."GlueCEInfoApplicationDir:  $app\n"
                                 ."GlueCEInfoDataDir: $data\n";
            foreach $vo (@vo_list){
                $contents = $contents."GlueCEAccessControlBaseRule: VO:$vo\n";
            }

            if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
                $contents = $contents."GlueCEInfoDefaultSE:  $fullhost\n";
            } else {
                $contents = $contents."GlueCEInfoDefaultSE: $default_se\n";
            }
        }
    }
    else{
        foreach $vo (@vo_list){
            $contents = $contents."\ndn: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n"
                                 ."GlueCEName: $vo\n"
                                 ."GlueForeignKey: GlueClusterUniqueID=$fullhost\n"
                                 ."GlueCEAccessControlBaseRule: VO:$vo\n"
                                 ."GlueCEInfoContactString: $fullhost:2119/jobmanager-$batch-$vo\n"
                                 ."GlueCEInfoApplicationDir:  $app\n"
                                 ."GlueCEInfoDataDir: $data\n";

            if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
                $contents = $contents."GlueCEInfoDefaultSE:  $fullhost\n";
            } else {
                $contents = $contents."GlueCEInfoDefaultSE: $default_se\n";
            }
        }
    }

    if ($batch =~ /^pbs$/i) {
        foreach my $queue (keys %pbsQueues){

            foreach $vo (@{$pbsQueues{$queue}}){
                $contents = $contents."\ndn: GlueVOViewLocalID=$vo,GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
                $contents = $contents."GlueCEAccessControlBaseRule: VO:$vo\n";

                if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
                    $contents = $contents."GlueCEInfoDefaultSE:  $fullhost\n";
                } else {
                    $contents = $contents."GlueCEInfoDefaultSE: $default_se\n";
                }

                $contents = $contents."GlueCEInfoApplicationDir:  $app\n"
                                     ."GlueCEInfoDataDir: $data\n"
                                     ."GlueChunkKey: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
            }
        }
    } elsif ($batch =~ /^lsf$/i) {
        foreach my $queue (@lsfQueues){
            foreach $vo (@vo_list){
                $contents = $contents."\ndn: GlueVOViewLocalID=$vo,GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
                $contents = $contents."GlueCEAccessControlBaseRule: VO:$vo\n";

                if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
                    $contents = $contents."GlueCEInfoDefaultSE:  $fullhost\n";
                } else {
                    $contents = $contents."GlueCEInfoDefaultSE: $default_se\n";
                }

                $contents = $contents."GlueCEInfoApplicationDir:  $app\n"
                                     ."GlueCEInfoDataDir: $data\n"
                                     ."GlueChunkKey: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
            }
        }
    }else{
        foreach $vo (@vo_list){
            $contents = $contents."\ndn: GlueVOViewLocalID=$vo,GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n"
                                 ."GlueCEAccessControlBaseRule: VO:$vo\n";

            if ($default_se =~ /^UNDEFINED$/i || $default_se =~ /^UNAVAILABLE$/i || $default_se eq "") {
                $contents = $contents."GlueCEInfoDefaultSE:  $fullhost\n";
            } else {
                $contents = $contents."GlueCEInfoDefaultSE: $default_se\n";
            }

            $contents = $contents."GlueCEInfoApplicationDir:  $app\n"
                                 ."GlueCEInfoDataDir: $data\n"
                                 ."GlueChunkKey: GlueCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n";
        }
    }

    if ($batch !~ /^pbs$/i) {
        safe_write($config_file, $contents);
    }

    vdt_install_log("===== BEGIN osg-info-static-ce.conf =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-ce.conf =====\n");

    return;
}

###########################################################################
#
# Function: create_se_config_file
# Purpose:  We create the static conf file osg-info-static-se.conf
#
###########################################################################
sub create_se_config_file
{
    my $config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-se.conf";
    my $contents    = "";

    # Write SE part of configuration. A site could publish both srm and gsiftp information through GIP simultaneously.
     my ($major_ver, $minor_ver) = split(/\./, $se_control_version);

    my $se_version=$major_ver;
    #print "$se_control_version, $major_ver , $minor_ver \n\n";

    if ($srm && $dynamic_dcache!=1) {
        $contents=$contents."\ndn: GlueSEUniqueID=$se_host\n"
                           ."GlueSEName: $se_name:srm_v$se_version\n"
                           ."GlueSEPort: 8443\n"
                           ."GlueSESizeTotal: 0\n"
                           ."GlueSESizeFree: 0\n"
                           ."GlueSEArchitecture: other\n"
                           ."GlueSEImplementationName: $srm_implementation_name\n"
                           ."GlueSEImplementationVersion: $srm_implementation_version\n"
                           ."GlueSEStatus: Production\n"
                           ."GlueSETotalOnlineSize: 0\n"
                           ."GlueSEUsedOnlineSize: 0\n"
                           ."GlueSETotalNearlineSize: 0\n"
                           ."GlueSEUsedNearlineSize: 0\n"
                           ."GlueForeignKey: GlueSiteUniqueID=$fullhost\n"
                           ."GlueInformationServiceURL: $bdii_contact\n";


        $contents=$contents."\ndn: GlueSEAccessProtocolLocalID=gsiftp,GlueSEUniqueID=$se_host\n"
                           ."GlueSEAccessProtocolType: gsiftp\n"
                           ."GlueSEAccessProtocolPort: 2811\n"
                           ."GlueSEAccessProtocolVersion: $se_access_version\n"
                           ."GlueSEAccessProtocolSupportedSecurity: gsi\n"
               ."GlueSEAccessProtocolMaxStreams: 1\n";

    for(my $i=0; $i<$se_access_number; $i++){
            $contents=$contents."GlueSEAccessProtocolEndpoint: $gridftp_doors[$i]\n";
        }

        $contents=$contents."GlueChunkKey: GlueSEUniqueID=$se_host\n\n";


        if($se_version eq '2') {
           $contents=$contents."\ndn: GlueSEControlProtocolLocalID=srm_v2,GlueSEUniqueID=$se_host\n"
                              ."GlueSEControlProtocolType: SRM\n"
                              ."GlueSEControlProtocolEndpoint: httpg://$se_host:8443/srm/managerv2\n"
                              ."GlueSEControlProtocolVersion: 2.2.0\n"
                              ."GlueSEControlProtocolCapability: control\n"
                              ."GlueChunkKey: GlueSEUniqueID=$se_host\n\n";
        }

        $contents=$contents."\ndn: GlueSEControlProtocolLocalID=srm_v1,GlueSEUniqueID=$se_host\n"
                           ."GlueSEControlProtocolType: SRM\n"
                           ."GlueSEControlProtocolEndpoint: httpg://$se_host:8443/srm/managerv1\n"
                           ."GlueSEControlProtocolVersion: 1.1.0\n"
                           ."GlueSEControlProtocolCapability: control\n"
                           ."GlueChunkKey: GlueSEUniqueID=$se_host\n\n";



        my $service_contents="\ndn: GlueServiceUniqueID=httpg://$se_host:8443/srm/managerv$se_version\n"
            ."GlueServiceUniqueID: httpg://$se_host:8443/srm/managerv$se_version\n"
            ."GlueServiceName: $se_host\n"
            ."GlueServiceType: SRM\n"
            ."GlueServiceVersion: $se_control_version\n"
            ."GlueServiceEndpoint: httpg://$se_host:8443/srm/managerv$se_version\n"
            ."GlueServiceURI: httpg://$se_host:8443/srm/managerv$se_version\n"
            ."GlueServiceAccessPointURL: httpg://$se_host:8443/srm/managerv$se_version\n"
            ."GlueServiceStatus: OK\n"
            ."GlueServiceStatusInfo: Production\n"
            ."GlueServiceWSDL: UNDEFINED\n"
            ."GlueServiceSemantics: UNDEFINED\n"
            ."GlueServiceStartTime: 1970-01-01T00:00:00Z\n"
            ."GlueServiceOwner:OSG\n";
        foreach $vo (@vo_list) {
                                $service_contents=$service_contents."GlueServiceAccessControlRule: $vo\n";
        }
        $service_contents=$service_contents."\n";
        $service_contents=$service_contents."GlueForeignKey: GlueSiteUniqueID=$fullhost\n";

        my $service_config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-service.conf";
        safe_write($service_config_file, $service_contents);
        vdt_install_log("===== BEGIN osg-info-static-service.conf =====\n");
        vdt_install_log($service_contents);
        vdt_install_log("===== END osg-info-static-service.conf =====\n");


        foreach $vo (@vo_list){

            my $se_access_root = $vo_access_roots{$vo};
            if ($se_access_root!~/^$/) {
                $se_access{$vo} = $se_access_root;
                $contents=$contents."\ndn: GlueSALocalID=$vo,GlueSEUniqueID=$se_host\n"
                                   ."GlueSARoot: $vo:$se_access_root\n"
                                   ."GlueSAPath: $se_access_root\n"
                                   ."GlueSAAccessControlBaseRule: $vo\n"
                                   ."GlueChunkKey: GlueSEUniqueID=$se_host\n"
                                   ."GlueSAType: permanent\n"
                                   ."GlueSAPolicyFileLifeTime: Permanent\n"
                                   ."GlueSAName: $vo\n"
                                   ."GlueSATotalOnlineSize: 0\n"
                                   ."GlueSAUsedOnlineSize: 0\n"
                                   ."GlueSAFreeOnlineSize: 0\n"
                                   ."GlueSAReservedOnlineSize: 0\n"
                                   ."GlueSATotalNearlineSize: 0\n"
                                   ."GlueSAUsedNearlineSize: 0\n"
                                   ."GlueSAFreeNearlineSize: 0\n"
                                   ."GlueSAReservedNearlineSize: 0\n"
                                   ."GlueSARetentionPolicy: Online\n"
                                   ."GlueSAAccessLatency: online\n"
                                   ."GlueSAExpirationMode: neverExpire\\n"
                                   ."GlueSACapability: file transfer\n"
                                   ."GlueSAPolicyMaxFileSize: 10000\n"
                                   ."GlueSAPolicyMinFileSize: 1\n"
                                   ."GlueSAPolicyMaxData: 100\n"
                                   ."GlueSAPolicyMaxNumFiles: 10\n"
                                   ."GlueSAPolicyMaxPinDuration: 10\n"
                                   ."GlueSAPolicyQuota: 0\n"
                                   ."GlueSAStateAvailableSpace: 0\n"
                                   ."GlueSAStateUsedSpace: 0\n\n";

                $contents=$contents."dn: GlueVOInfoLocalID=$vo,GlueSALocalID=$vo,GlueSEUniqueID=$se_host\n"
                                   ."GlueChunkKey: GlueSALocalID=$vo\n"
                                   ."GlueChunkKey: GlueSEUniqueID=$se_host\n"
                                   ."GlueVOInfoLocalID: $vo\n"
                                   ."GlueVOInfoName: $vo\n"
                                   ."GlueVOInfoPath: $se_access_root\n"
                                   ."GlueVOInfoAccessControlBaseRule: $vo\n"
                                   ."GlueVOInfoTag: UNAVAILABLE\n\n";


            }
        }

    }

    if ($srm && $dynamic_dcache==1) {
        
        foreach $vo (@vo_list){
            my $se_access_root = $vo_access_roots{$vo};
            if ($se_access_root!~/^$/) {
                $se_access{$vo} = $se_access_root;
            }              
        }                  
    }                      

    if ($disk) {
        $contents=$contents."\ndn: GlueSEUniqueID=$se_disk\n"
                           ."GlueSEName: $osg_site_name:disk\n"
                           ."GlueSEType: disk\n"
                           ."GlueSEPort: 2811\n"
                           ."GlueSESizeTotal: 0\n"
                           ."GlueSESizeFree: 0\n"
                           ."GlueSEArchitecture: disk\n"
                           ."GlueSEImplementationName: local disk\n"
                           ."GlueSEImplementationVersion: UNDEFINED\n"
                           ."GlueSEStatus: Production\n"
                           ."GlueSETotalOnlineSize: 0\n"
                           ."GlueSEUsedOnlineSize: 0\n"
                           ."GlueSETotalNearlineSize: 0\n"
                           ."GlueSEUsedNearlineSize: 0\n"
                           ."GlueForeignKey: GlueSiteUniqueID=$fullhost\n"
                           ."GlueInformationServiceURL: $bdii_contact\n";



        $contents=$contents."\ndn: GlueSEAccessProtocolLocalID=gsiftp,GlueSEUniqueID=$se_disk\n"
                           ."GlueSEAccessProtocolType: gsiftp\n"
                           ."GlueSEAccessProtocolPort: 2811\n"
                           ."GlueSEAccessProtocolVersion: 1.0.0\n"
               ."GlueSEAccessProtocolMaxStreams: 1\n"
                           ."GlueSEAccessProtocolSupportedSecurity: gsi\n"
                           ."GlueChunkKey: GlueSEUniqueID=$se_disk\n\n";



        $contents=$contents."\ndn: GlueSALocalID=$se_disk,GlueSEUniqueID=$se_disk\n"
                           ."GlueSARoot: $se_data\n"
                           ."GlueSAPath: $se_data\n";
        foreach $vo (@vo_list){
            $contents=$contents."GlueSAAccessControlBaseRule: $vo\n"
        }
        $contents=$contents."GlueChunkKey: GlueSEUniqueID=$se_disk\n"
                           ."GlueSAType: permanent\n"
                           ."GlueSAPolicyFileLifeTime: Permanent\n"
                           ."GlueSAName: $se_disk\n"
                           ."GlueSATotalOnlineSize: 0\n"
                           ."GlueSAUsedOnlineSize: 0\n"
                           ."GlueSAFreeOnlineSize: 0\n"
                           ."GlueSAReservedOnlineSize: 0\n"
                           ."GlueSATotalNearlineSize: 0\n"
                           ."GlueSAUsedNearlineSize: 0\n"
                           ."GlueSAFreeNearlineSize: 0\n"
                           ."GlueSAReservedNearlineSize: 0\n"
                           ."GlueSARetentionPolicy: Online\n"
                           ."GlueSAAccessLatency: online\n"
                           ."GlueSAExpirationMode: UNDEFINED\n"
                           ."GlueSACapability: UNDEFINED\n"
                           ."GlueSAPolicyMaxFileSize: 10000\n"
                           ."GlueSAPolicyMinFileSize: 1\n"
                           ."GlueSAPolicyMaxData: 100\n"
                           ."GlueSAPolicyMaxNumFiles: 10\n"
                           ."GlueSAPolicyMaxPinDuration: 10\n"
                           ."GlueSAPolicyQuota: 0\n"
                           ."GlueSAStateAvailableSpace: 1\n"
                           ."GlueSAStateUsedSpace: 1\n\n";

        $contents=$contents."dn: GlueVOInfoLocalID=$se_disk,GlueSALocalID=$se_disk\n"
                           ."GlueChunkKey: GlueSALocalID=$se_disk\n"
                           ."GlueVOInfoLocalID: $se_disk\n"
                           ."GlueVOInfoName: $se_disk\n"
                           ."GlueVOInfoPath: $se_data\n";
        foreach $vo (@vo_list){
                           $contents=$contents."GlueVOInfoAccessControlBaseRule: $vo\n";
        }
                           $contents=$contents."GlueVOInfoTag: UNAVAILABLE\n\n";

        foreach $vo (@vo_list){
            $contents=$contents."\ndn: GlueSALocalID=$vo,GlueSEUniqueID=$se_disk\n"
                               ."GlueSARoot: $vo:$vo\n"
                               ."GlueSAPath: $se_data\n"
                               ."GlueSAAccessControlBaseRule: $vo\n"
                               ."GlueChunkKey: GlueSEUniqueID=$se_disk\n"
                               ."GlueSAType: permanent\n"
                               ."GlueSAPolicyFileLifeTime: Permanent\n"
                               ."GlueSAName: $vo\n"
                               ."GlueSATotalOnlineSize: 0\n"
                               ."GlueSAUsedOnlineSize: 0\n"
                               ."GlueSAFreeOnlineSize: 0\n"
                               ."GlueSAReservedOnlineSize: 0\n"
                               ."GlueSATotalNearlineSize: 0\n"
                               ."GlueSAUsedNearlineSize: 0\n"
                               ."GlueSAFreeNearlineSize: 0\n"
                               ."GlueSAReservedNearlineSize: 0\n"
                               ."GlueSARetentionPolicy: UNDEFINED\n"
                               ."GlueSAAccessLatency: online\n"
                               ."GlueSAExpirationMode: UNDEFINED\n"
                               ."GlueSACapability: UNDEFINED\n"
                               ."GlueSAPolicyMaxFileSize: 10000\n"
                               ."GlueSAPolicyMinFileSize: 1\n"
                               ."GlueSAPolicyMaxData: 100\n"
                               ."GlueSAPolicyMaxNumFiles: 10\n"
                               ."GlueSAPolicyMaxPinDuration: 10\n"
                               ."GlueSAPolicyQuota: 0\n"
                               ."GlueSAStateAvailableSpace: 1\n"
                               ."GlueSAStateUsedSpace: 1\n\n";

            $contents=$contents."dn: GlueVOInfoLocalID=$vo,GlueSALocalID=$vo\n"
                               ."GlueChunkKey: GlueSALocalID=$vo\n"
                               ."GlueVOInfoLocalID: $vo\n"
                               ."GlueVOInfoName: $vo\n"
                               ."GlueVOInfoPath: $se_data\n"
                               ."GlueVOInfoAccessControlBaseRule: $vo\n"
                               ."GlueVOInfoTag: UNAVAILABLE\n\n";
        }
    }

    safe_write($config_file, $contents);

    vdt_install_log("===== BEGIN osg-info-static-se.conf =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-se.conf =====\n");

    return;
}

###########################################################################
#
# Function: create_cesebind_config_file
# Purpose:  We create the static conf file osg-info-static-cesebind.conf
#
###########################################################################
sub create_cesebind_config_file
{

    my $config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-cesebind.conf";
    my $contents    = "";

    if ($batch =~ /^pbs$/i) {
        foreach my $queue (keys %pbsQueues){
            $contents = $contents."\ndn: GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
            if ($disk) {
                $contents = $contents."GlueCESEBindGroupSEUniqueID: $se_disk\n";
            }
            if ($srm) {
                $contents = $contents."GlueCESEBindGroupSEUniqueID: $se_host\n";
            }

            if ($disk) {
                $contents = $contents."\ndn: GlueCESEBindSEUniqueID=$se_disk, GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n"
                                     ."GlueCESEBindCEAccesspoint: $data\n"
                                     ."GlueCESEBindCEUniqueID: $fullhost:2119/jobmanager-$batch-$queue\n";
            }

            if ($srm && defined $sa_path) {
                $contents = $contents."\ndn: GlueCESEBindSEUniqueID=$se_host, GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n"
                                     ."GlueCESEBindCEAccesspoint: $sa_path\n"
                                     ."GlueCESEBindCEUniqueID: $fullhost:2119/jobmanager-$batch-$queue\n";
            }
        }
    } elsif ($batch =~ /^lsf$/i) {
        foreach my $queue (@lsfQueues){
            $contents = $contents."\ndn: GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n";
            if ($disk) {
                $contents = $contents."GlueCESEBindGroupSEUniqueID: $se_disk\n";
            }
            if ($srm) {
                $contents = $contents."GlueCESEBindGroupSEUniqueID: $se_host\n";
            }

            if ($disk) {
                $contents = $contents."\ndn: GlueCESEBindSEUniqueID=$se_disk, GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n"
                                     ."GlueCESEBindCEAccesspoint: $data\n"
                                     ."GlueCESEBindCEUniqueID: $fullhost:2119/jobmanager-$batch-$queue\n";
            }

            if ($srm && defined $sa_path) {
                $contents = $contents."\ndn: GlueCESEBindSEUniqueID=$se_host, GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$queue\n"
                                     ."GlueCESEBindCEAccesspoint: $sa_path\n"
                                     ."GlueCESEBindCEUniqueID: $fullhost:2119/jobmanager-$batch-$queue\n";
            }
        }
    }else{
        foreach $vo (@vo_list){
            $contents = $contents."\ndn: GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n";
            if ($disk) {
                $contents = $contents."GlueCESEBindGroupSEUniqueID: $se_disk\n";
            }
            if ($srm) {
                $contents = $contents."GlueCESEBindGroupSEUniqueID: $se_host\n";
            }

            if ($disk) {
                $contents = $contents."\ndn: GlueCESEBindSEUniqueID=$se_disk, GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n"
                                     ."GlueCESEBindCEAccesspoint: $data\n"
                                     ."GlueCESEBindCEUniqueID: $fullhost:2119/jobmanager-$batch-$vo\n";
            }

            if ($srm && exists $se_access{$vo} && defined $sa_path) {
                $contents = $contents."\ndn: GlueCESEBindSEUniqueID=$se_host, GlueCESEBindGroupCEUniqueID=$fullhost:2119/jobmanager-$batch-$vo\n"
                                     ."GlueCESEBindCEAccesspoint: $se_access{$vo}\n"
                                     ."GlueCESEBindCEUniqueID: $fullhost:2119/jobmanager-$batch-$vo\n";
            }
        }
    }

    if ($batch !~ /pbs|lsf/i) {
        safe_write($config_file, $contents);

        vdt_install_log("===== BEGIN osg-info-static-cesebind.conf =====\n");
        vdt_install_log($contents);
        vdt_install_log("===== END osg-info-static-cesebind.conf =====\n");
    }

    return;
}
#
###########################################################################
#
# Function: create_service_config_file
# Purpose:  We create the static conf file osg-info-static-service.conf
#
###########################################################################
sub create_service_config_file
{

    my $config_file = "$gip_location/etc/osg-info-gip-config/osg-info-static-service.conf";
    my $contents    = "\n";

    if(-e $config_file) {
        my $tmp;
        open(FILE,$config_file) || die "Could not open the config_file\n";
        while($tmp=<FILE>) {
            $contents.=$tmp;
        }
        close(FILE);
    }

    safe_write($config_file, $contents);

    vdt_install_log("===== BEGIN osg-info-static-service.conf =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-service.conf =====\n");

    return;
}

###########################################################################
#
# Function: create_generic_config_file
# Purpose:  We create the static conf file osg-info-generic.conf
#
###########################################################################
sub create_generic_config_file
{
    my $config_file = "$gip_location/etc/osg-info-generic.conf";
    if (-e $config_file){
        vdt_install_log("Warning: osg-info-generic.conf left unchanged since it already exists")
    }else{
        my $contents    = "";

        $contents = $contents."temp_dir = $gip_location/var/tmp\n"
                             ."plugin_dir = $gip_location/plugins\n"
                             ."static_dir = $gip_location/var/ldif\n"
                             ."provider_dir = $gip_location/providers\n"
                             ."freshness = 300\n"
                             ."cache_ttl = 600\n"
                             ."response = 60\n"
                             ."timeout = 150\n";

        safe_write($config_file, $contents);

        vdt_install_log("===== BEGIN osg-info-generic.conf =====\n");
        vdt_install_log($contents);
        vdt_install_log("===== END osg-info-generic.conf =====\n");
    }
    return;
}

###########################################################################
#
# Function: create_config_file
# Purpose:  We copy the example GIP configuration file and edit it as best
#           we can on behalf of the sysadmin. Note that there is still a lot of
#           editing to be done. For example, we change things like
#           jobmanager-pbs to jobmanager-condor, but they also have
#           jobmanager-pbs-{short|medium|long}, which will probably never
#           exist on a Condor pool. It will just require hand-editing by
#           the system administrator.
#
###########################################################################
sub create_config_file
{
    create_site_config_file
    create_cluster_config_file();
    create_ce_config_file();
    create_se_config_file();
    create_cesebind_config_file();
    create_service_config_file();
    create_generic_config_file();
    create_wrapper_files();
    create_static_ldif_files();
    return;
}

###########################################################################
#
# Function: create_wrapper_files
# Purpose:  We create the necessary wrapper files
#
###########################################################################
sub create_wrapper_files
{

    #Create provider wrapper when necessary (Currently used for gums-monitoring)
    my $wrapper_file = "$gip_location/providers/osg-info-dynamic-providers";
    my $contents='#!/bin/sh';
    $contents=$contents."\n"."$gip_location/libexec/osg-info-software-provider.py \n";
    if ($gums == 1){
        $contents=$contents."\n"."$gip_location/libexec/osg-info-gums-status-probe $vdt_location\n";
    }
    if ($batch =~ /^pbs$/i) {
        $contents=$contents."\n"."$gip_location/libexec/osg-info-provider-pbs.py\n";
        $contents=$contents."\n"."$gip_location/libexec/osg_info_cesebind.py\n";
    }
    if ($batch =~ /^lsf$/i) {
        $contents=$contents."\n"."$gip_location/libexec/osg_info_provider_pbs.py\n";
        $contents=$contents."\n"."$gip_location/libexec/osg_info_cesebind.py\n";
    }
    if ($dynamic_dcache == 1) {
        $contents = $contents."\n$gip_location/libexec/services_info_provider.py\n";
        $contents = $contents."\n$gip_location/libexec/token_info_provider.py\n";
    }
    #$contents = $contents."\n"."$gip_location/libexec/osg_info_site.py\n";
    $contents = $contents."\nif [ -f \"$gip_location/etc/add-attributes.conf\" ]; then\n    cat $gip_location/etc/add-attributes.conf\nfi\n";

        #We remove the existing wrapper file because it will cause duplication of information
    system("rm -f $wrapper_file");
    safe_write($wrapper_file, $contents);
    system("chmod +x $wrapper_file");
    vdt_install_log("===== BEGIN osg-info-wrapper =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-wrapper =====\n");

    #Create plugin wrappers here

    $wrapper_file = "$gip_location/plugins/osg-info-dynamic-plugins";

    # Create appropriate lcg-info-dynamic-ce-plugin wrapper script in plugin dir
    my $ldif_file = "$gip_location/var/ldif/osg-info-static-ce.ldif";
    $contents = '#!/bin/sh'."\n";
    if ($batch =~ /^condor$/i) {
        # The condor script is different--it requires the path to the binaries as an argument.
        $contents = $contents."$gip_location/libexec/osg-info-dynamic-condor.py \n";
    }
    elsif ($batch =~ /^lsf$/i) {
        # The lsf script is also different--it requires the path to the binaries as an argument.
        $contents = $contents."$gip_location/libexec/osg-info-dynamic-lsf $lsf_bin_location $ldif_file \n";
    }
    elsif ($batch =~ /pbs/i) {
        # The pbs script is also different--it requires the path to the binaries as an argument.
        # $contents = $contents."$gip_location/libexec/osg-info-dynamic-pbs.py \n";
    }
    else {
        $contents = $contents."$gip_location/libexec/osg-info-dynamic-$batch $ldif_file \n";
    }

    # Create appropriate lcg-info-dynamic-software-plugin wrapper script in plugin dir. Not used by osg uses osg-info-dynamic-location plugin and osg-info-software-provider
    #$ldif_file = "$gip_location/var/gip/ldif/osg-info-static-cluster.ldif";
    #$contents = $contents."\n$gip_location/libexec/osg-info-dynamic-software $ldif_file $gip_location/var/info\n";


    # Create appropriate lcg-info-dynamic-location-plugin wrapper script in plugin dir
    $ldif_file = "$gip_location/var/ldif/osg-info-static-cluster.ldif";
    $contents = $contents."\n$gip_location/libexec/osg-info-dynamic-location $ldif_file $app/etc\n";

    # Create appropriate lcg-info-dynamic-se-plugin wrapper script in plugin dir
    $ldif_file = "$gip_location/var/ldif/osg-info-static-se.ldif";
    if($disk){
        $contents = $contents."\n$gip_location/libexec/osg-info-dynamic-classicSE $ldif_file $app/etc\n";
    }
    # This script has been deprecated (newer versions of dcache have disabled this functionality)
    # if($srm){
    #     $contents = $contents."\n$gip_location/libexec/osg-info-dynamic-dcache $ldif_file $vdt_location\n";
    # }

    $contents = $contents."\nif [ -f \"$gip_location/etc/alter-attributes.conf\" ]; then\n    cat $gip_location/etc/alter-attributes.conf\nfi\n";

    #We remove the existing wrapper file because it will cause duplication of information
    system("rm -f $wrapper_file");

    safe_write($wrapper_file, $contents);
    system("chmod +x $wrapper_file");
    vdt_install_log("===== BEGIN osg-info-dynamic-plugins =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-dynamic-plugins =====\n");
}

###########################################################################
#
# Function: create_static_ldif_files
# Purpose:  We create the following static ldif files
#           1. osg-info-static-site.ldif
#           2. osg-info-static-cluster.ldif
#           3. osg-info-static-ce.ldif
#           4. osg-info-static-se.ldif
#           5. osg-info-static-cesebind.ldif
#           6. osg-info-static-service.ldif
#
###########################################################################
sub create_static_ldif_files
{

    my $contents = `$gip_location/libexec/gip-static-create -c $gip_location/etc/osg-info-gip-config/osg-info-static-site.conf -t $gip_location/templates/compat/GlueSite.template`;

    safe_write("$gip_location/var/ldif/osg-info-static-site.ldif", $contents);

    vdt_install_log("===== BEGIN osg-info-static-site.ldif =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-site.ldif =====\n");

    $contents = `$gip_location/libexec/gip-static-create -c $gip_location/etc/osg-info-gip-config/osg-info-static-cluster.conf -t $gip_location/templates/compat/GlueCluster.template`;

    safe_write("$gip_location/var/ldif/osg-info-static-cluster.ldif", $contents);

    vdt_install_log("===== BEGIN osg-info-static-cluster.ldif =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-cluster.ldif =====\n");

    $contents = `$gip_location/libexec/gip-static-create -c $gip_location/etc/osg-info-gip-config/osg-info-static-ce.conf -t $gip_location/templates/compat/GlueCE.template`;

    safe_write("$gip_location/var/ldif/osg-info-static-ce.ldif", $contents);

    vdt_install_log("===== BEGIN osg-info-static-ce.ldif =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-ce.ldif =====\n");

    $contents = `$gip_location/libexec/gip-static-create -c $gip_location/etc/osg-info-gip-config/osg-info-static-se.conf -t $gip_location/templates/compat/GlueSE.template`;

    safe_write("$gip_location/var/ldif/osg-info-static-se.ldif", $contents);

    vdt_install_log("===== BEGIN osg-info-static-se.ldif =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-se.ldif =====\n");

    $contents = `$gip_location/libexec/gip-static-create -c $gip_location/etc/osg-info-gip-config/osg-info-static-cesebind.conf -t $gip_location/templates/compat/GlueCESEBind.template`;

    safe_write("$gip_location/var/ldif/osg-info-static-cesebind.ldif", $contents);

    vdt_install_log("===== BEGIN osg-info-static-cesebind.ldif =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-cesebind.ldif =====\n");

    $contents = `$gip_location/libexec/gip-static-create -c $gip_location/etc/osg-info-gip-config/osg-info-static-service.conf -t $gip_location/templates/compat/GlueService.template`;

    safe_write("$gip_location/var/ldif/osg-info-static-service.ldif", $contents);

    vdt_install_log("===== BEGIN osg-info-static-service.ldif =====\n");
    vdt_install_log($contents);
    vdt_install_log("===== END osg-info-static-service.ldif =====\n");

}

###########################################################################
#
# Function: setup_cemon
# Purpose:  Links CEmonitor with the GIP
#
###########################################################################
sub setup_cemon
{
   ##
   ## Check to make sure CEMon is installed
   ##
      return unless(-d "${vdt_location}/glite/etc/glite-ce-ce-plugin");

   ##
   ## Create our plugin script
   ##
   my $glite_plugin = "${vdt_location}/glite/etc/glite-ce-ce-plugin/glite-ce-info";
   my $contents = "#!/bin/sh\n".
                  "${vdt_location}/gip/libexec/osg-info-wrapper";
   safe_write($glite_plugin, $contents);
   system("chmod 0755 $glite_plugin");
}


